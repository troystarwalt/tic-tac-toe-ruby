quit
game.board
cell_location
cell_location[q][0].value = "O"
q = rand(0..x)
x
x = cell_location.size - 1
cell_location.size
rand(1..9)
rand
cell_location[1]
cell_location[0]
cell_location.rand(1,9)
cell_location.rand
cell_location.first.first.class
cell_location.first.first.value.class
cell_location.first.first.value
cell_location.first.first
cell_location.first.value
cell_location.first
cell_location.size
cell_location
quit
cell_location
continue
cell_location
next
ncext
next
step
next
step
cell_location
continue
cell.value
cell
continue
step
continue
quit
game.board.grid.each_with_index { |cell, i| puts @value }
game.board.grid.each_with_index { |cell, i| puts cell.@value }
game.board.grid.each_with_index { |cell, i| puts cell.value }
game.board.grid.each_with_index { |cell, i| puts i }
game.board.grid.each_with_index { |cell, i| puts cell }
game.board.grid
game.board.grid.class
game.board.class
game.class
game.board.grid.each_with_index { |cell, i| puts cell i }
game.board.grid
moves
step
step(30)
step(30
step
continue
step
cell
step
cell
moves
step
moves
step
continue
game.board.grid.each  { |row| row.each { |cell| puts cell.value }}
game.board.grid.each  { |row| row.each { |cell| puts cell }}
game.board.grid.each do { |row| puts row }
game.board.grid.each do { |row| puts row.map }
game.board.grid.each do
game.board.grid.class
game.board.grid
game.board.grid.each do { |row| row.each do { |cell| puts cell }}
game.board.grid.each do
game.board.grid.each { |cell| puts cell.size }
game.board.grid.each { |cell| puts cell.class }
game.board.grid.each { |cell| puts cell.value }
game.board.grid.each { |cell| puts cell }
game.board.each { |cell| puts cell }
game.board.grid.each { |cell| puts cell }
game.board.grid.each { |cell| puts cell.value }
game.board.each { |cell| puts cell.value }
game.board
game.grid
game
grid
quit
grid + grid.transpose + diagonals
grid + grid.transpose
grid
quit
continue
quit
get_cell(0,0)
grid[0][0]
grid
quit
continue
step
quit
input
value
self
continue
board.grid[0][0].value = "X"
board.grid[0][0].value
board.grid
board
quit
self.board.grid[0][0].value = "X"
self.board.grid[0][0].value
self.board.grid[0][0]
self.board.grid
self.board
self.grid
self.class
self
@grid
@board
@current_player
continue
step
cell
step
y
x
x, y
input
step
quit
get_cell(cell)
cell
step
input
continue
input
game.board.grid[input]
game.board.grid(input)
game.board.grid
game.board.cell
game.board.is_available(input)
game.board
game.board.
step
input
continue
input
quit
input
continue
@value
game.board.grid[1][1].value = "X"
game.board.grid[1][1].value == "X"
game.board.grid[1][1].value
@value
@value = "X"
@value
@value = game.board.grid[1][1].value
game.board.grid[1][1].value
game.board.grid[1][1].value = "X"
game.board.grid[1][1].value
game.board.grid[1][1].value == "X"
game.board.grid[1][1].value == "a"
game.board.grid[1][1].value == ""
game.board.grid[1][1].value
game.board.grid[1][1]
game.board.grid[1][1].nil?
game.board.grid[1][1].class
game.board.grid[1][1].value.class
game.board.grid[1][1].value
game.board.grid[1][1]
game.board.grid[0, 1]
game.board.grid[0, 1].length
game.board.grid[0, 1].size
game.board.grid[0, 1].cell
game.board.grid[0, 1].value
game.board.grid[0, 1]
game.board.grid[0, 0]
game.board.grid[0, 0].cell
game.board.grid.cell
game.board.je
game.board.cell
game.board.grid[0][1].value
game.board.grid[0][1].value?
game.board.grid[0][1]
game.board.grid[0, 0]
game.board.grid[0, 1]
game.board.grid.cell
game.board.grid
game.board
game.grid
game
quit
game.board.grid
game.board.inspect
game.board[0, 0]
game.board.cell
game.board[0]
game.board.cell = "X"
game.board.cell.nil?
game.board.cell
game.board.cell === nil?
game.board.cell == nil?
game.board.cell
game.board.class
game.board
game.board.empty?
game.board.cell.value.empty?
game.board.cell.value
game.board.cell.empty?
game.board.cell
game.board
board
boar
game
continue
game.board
game.board?
game.board
game
input
